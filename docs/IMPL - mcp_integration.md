# MCP Protocol Integration

## MCP Overview

### Model Context Protocol

The Model Context Protocol (MCP) is a standardized interface that enables AI assistants to access external tools and data sources. Code-Scout implements MCP as a server that provides code indexing and semantic search capabilities.

### Protocol Version

- **Target Version**: MCP 2024-11-05 (latest stable)
- **Transport**: Standard I/O (stdio) for local execution
- **Message Format**: JSON-RPC 2.0 over stdio
- **Server Version**: 0.1.0 (current package version)

## Server Architecture

### MCP Server Structure

```
src/api/mcp/
├── server.ts              # Main MCP server implementation
├── handlers.ts            # Tool and resource handlers
├── tools.ts               # Tool definitions and implementations
├── resources.ts           # Resource definitions and implementations
├── protocol.ts            # MCP protocol utilities
└── index.ts               # MCP server entry point
```

### Server Initialization

```typescript
class MCPServer {
  private server: Server;
  private tools: Map<string, ToolHandler>;
  private resources: Map<string, ResourceHandler>;

  constructor(
    private indexer: IndexerService,
    private queryEngine: QueryEngine
  ) {
    this.server = new Server(
      {
        name: 'code-scout-mcp',
        version: '0.1.0',
      },
      {
        capabilities: {
          tools: {},
          resources: {},
        },
      }
    );

    this.setupTools();
    this.setupResources();
    this.setupHandlers();
  }

  private setupTools() {
    this.tools.set('code-scout_search', this.handleSearch.bind(this));
    this.tools.set('code-scout_index', this.handleIndex.bind(this));
    this.tools.set('code-scout_status', this.handleStatus.bind(this));
  }
}
```

## Tool Definitions

### code-scout_search Tool

```typescript
const SEARCH_TOOL: Tool = {
  name: 'code-scout_search',
  description: 'Search code using LLM-generated tags with relevance scoring',
  inputSchema: {
    type: 'object',
    properties: {
      tags: {
        type: 'array',
        items: { type: 'string' },
        minItems: 1,
        maxItems: 5,
        description:
          'Array of search tags (1-5 tags) generated by LLM based on task context',
      },
      limit: {
        type: 'number',
        default: 20,
        minimum: 1,
        maximum: 100,
        description: 'Maximum results to return',
      },
      filters: {
        type: 'object',
        properties: {
          language: {
            type: 'string',
            enum: ['typescript', 'python'],
            description: 'Filter by programming language',
          },
          fileType: {
            type: 'string',
            description: "Filter by file extension (e.g., '.ts', '.py')",
          },
          path: {
            type: 'string',
            description: 'Filter by path pattern (supports glob syntax)',
          },
          hasExports: {
            type: 'boolean',
            description: 'Only include files with exports',
          },
          hasTests: {
            type: 'boolean',
            description: 'Include/exclude test files',
          },
        },
        description: 'Optional filters to narrow search results',
      },
    },
    required: ['tags'],
  },
};
```

### code-scout_index Tool

```typescript
const INDEX_TOOL: Tool = {
  name: 'code-scout_index',
  description: 'Initialize or update code index for current directory',
  inputSchema: {
    type: 'object',
    properties: {
      path: {
        type: 'string',
        description:
          'Directory path to index (optional, defaults to current working directory)',
      },
      force: {
        type: 'boolean',
        default: false,
        description: 'Force complete reindexing instead of incremental update',
      },
      background: {
        type: 'boolean',
        default: true,
        description: 'Run indexing in background (non-blocking)',
      },
    },
  },
};
```

### code-scout_status Tool

```typescript
const STATUS_TOOL: Tool = {
  name: 'code-scout_status',
  description: 'Get indexing status and database information',
  inputSchema: {
    type: 'object',
    properties: {
      path: {
        type: 'string',
        description:
          'Project path to check (optional, defaults to current directory)',
      },
    },
  },
};
```

## Tool Handlers

### Search Handler

```typescript
private async handleSearch(args: SearchArgs): Promise<ToolResponse> {
  try {
    // Validate input
    this.validateSearchArgs(args);

    // Execute search
    const result = await this.queryEngine.search({
      tags: args.tags,
      limit: args.limit || 20,
      filters: args.filters
    });

    // Format response
    return {
      content: [
        {
          type: "text",
          text: this.formatSearchResults(result)
        }
      ]
    };
  } catch (error) {
    return this.handleToolError(error);
  }
}

private validateSearchArgs(args: SearchArgs): void {
  if (!args.tags || !Array.isArray(args.tags) || args.tags.length === 0) {
    throw new ValidationError("At least one search tag is required");
  }

  if (args.tags.length > 5) {
    throw new ValidationError("Maximum 5 search tags allowed");
  }

  if (args.limit && (args.limit < 1 || args.limit > 100)) {
    throw new ValidationError("Limit must be between 1 and 100");
  }
}
```

### Index Handler

```typescript
private async handleIndex(args: IndexArgs): Promise<ToolResponse> {
  try {
    const path = args.path || process.cwd();

    // Validate path exists and is directory
    const stats = await fs.stat(path);
    if (!stats.isDirectory()) {
      throw new ValidationError("Path must be a directory");
    }

    // Start indexing
    if (args.background) {
      // Background indexing
      this.indexer.indexRepository(path, { force: args.force })
        .catch(error => this.log.error("Background indexing failed", error));

      return {
        content: [
          {
            type: "text",
            text: `Indexing started in background for: ${path}`
          }
        ]
      };
    } else {
      // Synchronous indexing
      const result = await this.indexer.indexRepository(path, { force: args.force });

      return {
        content: [
          {
            type: "text",
            text: `Indexing completed: ${result.totalFiles} files processed in ${result.indexingDuration}ms`
          }
        ]
      };
    }
  } catch (error) {
    return this.handleToolError(error);
  }
}
```

### Status Handler

```typescript
private async handleStatus(args: StatusArgs): Promise<ToolResponse> {
  try {
    const path = args.path || process.cwd();
    const stats = await this.indexer.getStatistics();

    const status = {
      projectPath: path,
      databasePath: "./.code-scout/database.db",
      status: stats.isIndexing ? "indexing" : "idle",
      filesIndexed: stats.totalFiles,
      lastIndexed: stats.lastIndexed,
      languages: stats.languages,
      indexSize: stats.databaseSize
    };

    return {
      content: [
        {
          type: "text",
          text: JSON.stringify(status, null, 2)
        }
      ]
    };
  } catch (error) {
    return this.handleToolError(error);
  }
}
```

## Response Formatting

### Search Results Format

```typescript
private formatSearchResults(result: SearchResult): string {
  let output = `# Query Results\n`;
  output += `**Total files:** ${result.totalFiles}\n`;
  output += `**Execution time:** ${result.executionTime}ms\n`;
  output += `**Results:** ${result.results.length}\n\n`;

  for (const item of result.results) {
    output += `### File: ${item.file.path}\n`;

    if (item.file.definitions.length > 0) {
      output += `**Definitions:** ${item.file.definitions.length}\n`;
      for (const def of item.file.definitions.slice(0, 5)) { // Limit for readability
        output += `- ${def.type} ${def.name}`;
        if (def.signature) output += ` ${def.signature}`;
        output += `\n`;
      }
      if (item.file.definitions.length > 5) {
        output += `- ... and ${item.file.definitions.length - 5} more\n`;
      }
    }

    if (item.file.imports.length > 0) {
      output += `**Imports:** ${item.file.imports.length}\n`;
      const grouped = this.groupImportsByType(item.file.imports);
      for (const [type, modules] of Object.entries(grouped)) {
        output += `- ${type}: ${modules.slice(0, 3).join(', ')}`;
        if (modules.length > 3) output += `, +${modules.length - 3} more`;
        output += `\n`;
      }
    }

    output += `\n`;
  }

  return output;
}

private groupImportsByType(imports: ImportMetadata[]): Record<string, string[]> {
  const grouped: Record<string, string[]> = {};
  for (const imp of imports) {
    if (!grouped[imp.type]) grouped[imp.type] = [];
    grouped[imp.type].push(imp.module);
  }
  return grouped;
}
```

## Resources

### Project Status Resource

```typescript
const PROJECT_STATUS_RESOURCE: Resource = {
  uri: 'code-scout://project/status',
  name: 'Project Index Status',
  description: 'Current indexing status and statistics',
  mimeType: 'application/json',
};
```

### Configuration Resource

```typescript
const CONFIGURATION_RESOURCE: Resource = {
  uri: 'code-scout://config',
  name: 'Code-Scout Configuration',
  description: 'Current configuration settings',
  mimeType: 'application/json',
};
```

## Error Handling

### MCP Error Codes

```typescript
enum MCPErrorCode {
  PARSE_ERROR = -32700,
  INVALID_REQUEST = -32600,
  METHOD_NOT_FOUND = -32601,
  INVALID_PARAMS = -32602,
  INTERNAL_ERROR = -32603,
}
```

### Tool Error Response

```typescript
private handleToolError(error: unknown): ToolResponse {
  const serviceError = error instanceof ServiceError ? error : new ServiceError('INTERNAL_ERROR', 'Unknown error occurred');

  return {
    content: [
      {
        type: "text",
        text: `Error: ${serviceError.message}`
      }
    ],
    isError: true
  };
}
```

## Protocol Compliance

### Message Handling

```typescript
private setupHandlers() {
  // Handle initialization
  this.server.setRequestHandler("initialize", this.handleInitialize.bind(this));

  // Handle tool calls
  this.server.setRequestHandler("tools/call", this.handleToolCall.bind(this));

  // Handle resource requests
  this.server.setRequestHandler("resources/read", this.handleResourceRead.bind(this));

  // Handle completion
  this.server.setRequestHandler("completion/complete", this.handleCompletion.bind(this));
}
```

### Initialization

```typescript
private handleInitialize(request: InitializeRequest): InitializeResult {
  return {
    protocolVersion: "2024-11-05",
    capabilities: {
      tools: {
        listChanged: true // Tools can change during session
      },
      resources: {
        listChanged: true
      }
    },
    serverInfo: {
      name: "code-scout-mcp",
      version: "0.1.0" // Current package version from package.json
    }
  };
}
```

## Testing MCP Integration

### Protocol Testing

- **Message Format**: Validate JSON-RPC 2.0 compliance
- **Tool Discovery**: Test tool listing and descriptions
- **Parameter Validation**: Test input schema validation
- **Error Responses**: Test error handling and formatting

### Integration Testing

- **Claude Code**: Test with Claude Code integration
- **VSCode Extension**: Test with VSCode MCP extension
- **Manual Testing**: Test with MCP client tools

### Performance Testing

- **Response Times**: Measure tool execution times
- **Concurrent Requests**: Test multiple simultaneous tool calls
- **Large Responses**: Test handling of large result sets

This MCP integration provides a standardized interface for AI assistants to access Code-Scout's code indexing and search capabilities.
